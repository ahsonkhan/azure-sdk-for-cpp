
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.
//
// Code generated by Microsoft (R) AutoRest C++ Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
#include <azure/data/appconfiguration/rest_client.hpp>

#include <string>

#include <azure/core/context.hpp>
#include <azure/core/datetime.hpp>
#include <azure/core/etag.hpp>
#include <azure/core/http/http.hpp>
#include <azure/core/http/http_status_code.hpp>
#include <azure/core/internal/http/pipeline.hpp>
#include <azure/core/internal/json/json.hpp>
#include <azure/core/io/body_stream.hpp>
#include <azure/core/response.hpp>
#include <azure/core/url.hpp>
#include <azure/storage/common/crypt.hpp>
#include <azure/storage/common/storage_exception.hpp>

namespace {
std::string Get6ItemsItemToString(
    const Azure::Data::AppConfiguration::Models::Get6ItemsItem &val) {
  const Azure::Data::AppConfiguration::Models::Get6ItemsItem valueList[] = {
      Azure::Data::AppConfiguration::Models::Get6ItemsItem::Key,
      Azure::Data::AppConfiguration::Models::Get6ItemsItem::Label,
      Azure::Data::AppConfiguration::Models::Get6ItemsItem::ContentType,
      Azure::Data::AppConfiguration::Models::Get6ItemsItem::Value,
      Azure::Data::AppConfiguration::Models::Get6ItemsItem::LastModified,
      Azure::Data::AppConfiguration::Models::Get6ItemsItem::Tags,
      Azure::Data::AppConfiguration::Models::Get6ItemsItem::Locked,
      Azure::Data::AppConfiguration::Models::Get6ItemsItem::Etag,
  };
  const char *stringList[] = {
      "key",           "label", "content_type", "value",
      "last_modified", "tags",  "locked",       "etag",
  };
  std::string ret;
  for (size_t i = 0; i < 8; ++i) {
    if ((val & valueList[i]) == valueList[i]) {
      if (!ret.empty()) {
        ret += ",";
      }
      ret += stringList[i];
    }
  }
  return ret;
}
std::string Head6ItemsItemToString(
    const Azure::Data::AppConfiguration::Models::Head6ItemsItem &val) {
  const Azure::Data::AppConfiguration::Models::Head6ItemsItem valueList[] = {
      Azure::Data::AppConfiguration::Models::Head6ItemsItem::Key,
      Azure::Data::AppConfiguration::Models::Head6ItemsItem::Label,
      Azure::Data::AppConfiguration::Models::Head6ItemsItem::ContentType,
      Azure::Data::AppConfiguration::Models::Head6ItemsItem::Value,
      Azure::Data::AppConfiguration::Models::Head6ItemsItem::LastModified,
      Azure::Data::AppConfiguration::Models::Head6ItemsItem::Tags,
      Azure::Data::AppConfiguration::Models::Head6ItemsItem::Locked,
      Azure::Data::AppConfiguration::Models::Head6ItemsItem::Etag,
  };
  const char *stringList[] = {
      "key",           "label", "content_type", "value",
      "last_modified", "tags",  "locked",       "etag",
  };
  std::string ret;
  for (size_t i = 0; i < 8; ++i) {
    if ((val & valueList[i]) == valueList[i]) {
      if (!ret.empty()) {
        ret += ",";
      }
      ret += stringList[i];
    }
  }
  return ret;
}
std::string Get7ItemsItemToString(
    const Azure::Data::AppConfiguration::Models::Get7ItemsItem &val) {
  const Azure::Data::AppConfiguration::Models::Get7ItemsItem valueList[] = {
      Azure::Data::AppConfiguration::Models::Get7ItemsItem::Key,
      Azure::Data::AppConfiguration::Models::Get7ItemsItem::Label,
      Azure::Data::AppConfiguration::Models::Get7ItemsItem::ContentType,
      Azure::Data::AppConfiguration::Models::Get7ItemsItem::Value,
      Azure::Data::AppConfiguration::Models::Get7ItemsItem::LastModified,
      Azure::Data::AppConfiguration::Models::Get7ItemsItem::Tags,
      Azure::Data::AppConfiguration::Models::Get7ItemsItem::Locked,
      Azure::Data::AppConfiguration::Models::Get7ItemsItem::Etag,
  };
  const char *stringList[] = {
      "key",           "label", "content_type", "value",
      "last_modified", "tags",  "locked",       "etag",
  };
  std::string ret;
  for (size_t i = 0; i < 8; ++i) {
    if ((val & valueList[i]) == valueList[i]) {
      if (!ret.empty()) {
        ret += ",";
      }
      ret += stringList[i];
    }
  }
  return ret;
}
std::string Head7ItemsItemToString(
    const Azure::Data::AppConfiguration::Models::Head7ItemsItem &val) {
  const Azure::Data::AppConfiguration::Models::Head7ItemsItem valueList[] = {
      Azure::Data::AppConfiguration::Models::Head7ItemsItem::Key,
      Azure::Data::AppConfiguration::Models::Head7ItemsItem::Label,
      Azure::Data::AppConfiguration::Models::Head7ItemsItem::ContentType,
      Azure::Data::AppConfiguration::Models::Head7ItemsItem::Value,
      Azure::Data::AppConfiguration::Models::Head7ItemsItem::LastModified,
      Azure::Data::AppConfiguration::Models::Head7ItemsItem::Tags,
      Azure::Data::AppConfiguration::Models::Head7ItemsItem::Locked,
      Azure::Data::AppConfiguration::Models::Head7ItemsItem::Etag,
  };
  const char *stringList[] = {
      "key",           "label", "content_type", "value",
      "last_modified", "tags",  "locked",       "etag",
  };
  std::string ret;
  for (size_t i = 0; i < 8; ++i) {
    if ((val & valueList[i]) == valueList[i]) {
      if (!ret.empty()) {
        ret += ",";
      }
      ret += stringList[i];
    }
  }
  return ret;
}
std::string Get5ItemsItemToString(
    const Azure::Data::AppConfiguration::Models::Get5ItemsItem &val) {
  const Azure::Data::AppConfiguration::Models::Get5ItemsItem valueList[] = {
      Azure::Data::AppConfiguration::Models::Get5ItemsItem::Name,
  };
  const char *stringList[] = {
      "name",
  };
  std::string ret;
  for (size_t i = 0; i < 1; ++i) {
    if ((val & valueList[i]) == valueList[i]) {
      if (!ret.empty()) {
        ret += ",";
      }
      ret += stringList[i];
    }
  }
  return ret;
}
std::string Head5ItemsItemToString(
    const Azure::Data::AppConfiguration::Models::Head5ItemsItem &val) {
  const Azure::Data::AppConfiguration::Models::Head5ItemsItem valueList[] = {
      Azure::Data::AppConfiguration::Models::Head5ItemsItem::Name,
  };
  const char *stringList[] = {
      "name",
  };
  std::string ret;
  for (size_t i = 0; i < 1; ++i) {
    if ((val & valueList[i]) == valueList[i]) {
      if (!ret.empty()) {
        ret += ",";
      }
      ret += stringList[i];
    }
  }
  return ret;
}
std::string
Enum6ToString(const Azure::Data::AppConfiguration::Models::Enum6 &val) {
  const Azure::Data::AppConfiguration::Models::Enum6 valueList[] = {
      Azure::Data::AppConfiguration::Models::Enum6::Key,
      Azure::Data::AppConfiguration::Models::Enum6::Label,
      Azure::Data::AppConfiguration::Models::Enum6::ContentType,
      Azure::Data::AppConfiguration::Models::Enum6::Value,
      Azure::Data::AppConfiguration::Models::Enum6::LastModified,
      Azure::Data::AppConfiguration::Models::Enum6::Tags,
      Azure::Data::AppConfiguration::Models::Enum6::Locked,
      Azure::Data::AppConfiguration::Models::Enum6::Etag,
  };
  const char *stringList[] = {
      "key",           "label", "content_type", "value",
      "last_modified", "tags",  "locked",       "etag",
  };
  std::string ret;
  for (size_t i = 0; i < 8; ++i) {
    if ((val & valueList[i]) == valueList[i]) {
      if (!ret.empty()) {
        ret += ",";
      }
      ret += stringList[i];
    }
  }
  return ret;
}
std::string
Enum7ToString(const Azure::Data::AppConfiguration::Models::Enum7 &val) {
  const Azure::Data::AppConfiguration::Models::Enum7 valueList[] = {
      Azure::Data::AppConfiguration::Models::Enum7::Key,
      Azure::Data::AppConfiguration::Models::Enum7::Label,
      Azure::Data::AppConfiguration::Models::Enum7::ContentType,
      Azure::Data::AppConfiguration::Models::Enum7::Value,
      Azure::Data::AppConfiguration::Models::Enum7::LastModified,
      Azure::Data::AppConfiguration::Models::Enum7::Tags,
      Azure::Data::AppConfiguration::Models::Enum7::Locked,
      Azure::Data::AppConfiguration::Models::Enum7::Etag,
  };
  const char *stringList[] = {
      "key",           "label", "content_type", "value",
      "last_modified", "tags",  "locked",       "etag",
  };
  std::string ret;
  for (size_t i = 0; i < 8; ++i) {
    if ((val & valueList[i]) == valueList[i]) {
      if (!ret.empty()) {
        ret += ",";
      }
      ret += stringList[i];
    }
  }
  return ret;
}
} // namespace
namespace Azure {
namespace Data {
namespace AppConfiguration {
namespace _detail {
Response<Models::KeyListResult>
Client::GetKeys(Core::Http::_internal::HttpPipeline &pipeline,
                const Core::Url &url, const GetKeysOptions &options,
                const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Get, url);
  if (options.Name.HasValue() && !options.Name.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "name",
        Storage::_internal::UrlEncodeQueryParameter(options.Name.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.After.HasValue() && !options.After.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "After",
        Storage::_internal::UrlEncodeQueryParameter(options.After.Value()));
  }
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::KeyListResult response;
  {
    const auto &responseBody = pRawResponse->GetBody();
    auto jsonRoot = Core::Json::_internal::json::parse(responseBody.begin(),
                                                       responseBody.end());
    for (const auto &var0 :
         jsonRoot.count("items") != 0 && jsonRoot["items"].is_array()
             ? jsonRoot["items"]
             : Core::Json::_internal::json::array()) {
      Models::Key vectorElement2;
      vectorElement2.Name = var0["name"].get<std::string>();
      response.Items.emplace_back(std::move(vectorElement2));
    }
    response.NextLink = jsonRoot["@nextLink"].get<std::string>();
  }
  return Response<Models::KeyListResult>(std::move(response),
                                         std::move(pRawResponse));
}
Response<Models::CheckKeysResult>
Client::CheckKeys(Core::Http::_internal::HttpPipeline &pipeline,
                  const Core::Url &url, const CheckKeysOptions &options,
                  const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Head, url);
  if (options.Name.HasValue() && !options.Name.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "name",
        Storage::_internal::UrlEncodeQueryParameter(options.Name.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.After.HasValue() && !options.After.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "After",
        Storage::_internal::UrlEncodeQueryParameter(options.After.Value()));
  }
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::CheckKeysResult response;
  response.SyncToken = pRawResponse->GetHeaders().at("Sync-Token");
  return Response<Models::CheckKeysResult>(std::move(response),
                                           std::move(pRawResponse));
}
Response<Models::KeyValueListResult>
Client::GetKeyValues(Core::Http::_internal::HttpPipeline &pipeline,
                     const Core::Url &url, const GetKeyValuesOptions &options,
                     const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Get, url);
  if (options.Key.HasValue() && !options.Key.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "key",
        Storage::_internal::UrlEncodeQueryParameter(options.Key.Value()));
  }
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.After.HasValue() && !options.After.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "After",
        Storage::_internal::UrlEncodeQueryParameter(options.After.Value()));
  }
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  if (options.Select.HasValue() &&
      !Get6ItemsItemToString(options.Select.Value()).empty()) {
    request.GetUrl().AppendQueryParameter(
        "$Select", Storage::_internal::UrlEncodeQueryParameter(
                       Get6ItemsItemToString(options.Select.Value())));
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::KeyValueListResult response;
  {
    const auto &responseBody = pRawResponse->GetBody();
    auto jsonRoot = Core::Json::_internal::json::parse(responseBody.begin(),
                                                       responseBody.end());
    for (const auto &var0 :
         jsonRoot.count("items") != 0 && jsonRoot["items"].is_array()
             ? jsonRoot["items"]
             : Core::Json::_internal::json::array()) {
      Models::KeyValue vectorElement2;
      vectorElement2.Key = var0["key"].get<std::string>();
      vectorElement2.Label = var0["label"].get<std::string>();
      vectorElement2.ContentType = var0["content_type"].get<std::string>();
      vectorElement2.Value = var0["value"].get<std::string>();
      vectorElement2.LastModified =
          DateTime::Parse(var0["last_modified"].get<std::string>(),
                          Azure::DateTime::DateFormat::Rfc3339);
      for (const auto &var2 :
           var0.count("tags") != 0 && var0["tags"].is_object()
               ? var0["tags"]
               : Core::Json::_internal::json::object()) {
        std::string var2Value;
        var2Value = var2.value().get<std::string>();
        vectorElement2.Tags.emplace(var2.key(), std::move(var2Value));
      }
      vectorElement2.Locked =
          var0["locked"].is_boolean()
              ? var0["locked"].get<bool>()
              : var0["locked"].get<std::string>() == std::string("true");
      vectorElement2.Etag = ETag(var0["etag"].get<std::string>());
      response.Items.emplace_back(std::move(vectorElement2));
    }
    response.NextLink = jsonRoot["@nextLink"].get<std::string>();
  }
  return Response<Models::KeyValueListResult>(std::move(response),
                                              std::move(pRawResponse));
}
Response<Models::CheckKeyValuesResult> Client::CheckKeyValues(
    Core::Http::_internal::HttpPipeline &pipeline, const Core::Url &url,
    const CheckKeyValuesOptions &options, const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Head, url);
  if (options.Key.HasValue() && !options.Key.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "key",
        Storage::_internal::UrlEncodeQueryParameter(options.Key.Value()));
  }
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.After.HasValue() && !options.After.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "After",
        Storage::_internal::UrlEncodeQueryParameter(options.After.Value()));
  }
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  if (options.Select.HasValue() &&
      !Head6ItemsItemToString(options.Select.Value()).empty()) {
    request.GetUrl().AppendQueryParameter(
        "$Select", Storage::_internal::UrlEncodeQueryParameter(
                       Head6ItemsItemToString(options.Select.Value())));
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::CheckKeyValuesResult response;
  response.SyncToken = pRawResponse->GetHeaders().at("Sync-Token");
  return Response<Models::CheckKeyValuesResult>(std::move(response),
                                                std::move(pRawResponse));
}
Response<Models::KeyValue>
Client::GetKeyValue(Core::Http::_internal::HttpPipeline &pipeline,
                    const Core::Url &url, const GetKeyValueOptions &options,
                    const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Get, url);
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  if (options.IfMatch.HasValue() && !options.IfMatch.ToString().empty()) {
    request.SetHeader("If-Match", options.IfMatch.ToString());
  }
  if (options.IfNoneMatch.HasValue() &&
      !options.IfNoneMatch.ToString().empty()) {
    request.SetHeader("If-None-Match", options.IfNoneMatch.ToString());
  }
  if (options.Select.HasValue() &&
      !Get7ItemsItemToString(options.Select.Value()).empty()) {
    request.GetUrl().AppendQueryParameter(
        "$Select", Storage::_internal::UrlEncodeQueryParameter(
                       Get7ItemsItemToString(options.Select.Value())));
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::KeyValue response;
  {
    const auto &responseBody = pRawResponse->GetBody();
    auto jsonRoot = Core::Json::_internal::json::parse(responseBody.begin(),
                                                       responseBody.end());
    response.Key = jsonRoot["key"].get<std::string>();
    response.Label = jsonRoot["label"].get<std::string>();
    response.ContentType = jsonRoot["content_type"].get<std::string>();
    response.Value = jsonRoot["value"].get<std::string>();
    response.LastModified =
        DateTime::Parse(jsonRoot["last_modified"].get<std::string>(),
                        Azure::DateTime::DateFormat::Rfc3339);
    for (const auto &var0 :
         jsonRoot.count("tags") != 0 && jsonRoot["tags"].is_object()
             ? jsonRoot["tags"]
             : Core::Json::_internal::json::object()) {
      std::string var0Value;
      var0Value = var0.value().get<std::string>();
      response.Tags.emplace(var0.key(), std::move(var0Value));
    }
    response.Locked =
        jsonRoot["locked"].is_boolean()
            ? jsonRoot["locked"].get<bool>()
            : jsonRoot["locked"].get<std::string>() == std::string("true");
    response.Etag = ETag(jsonRoot["etag"].get<std::string>());
  }
  response.LastModified =
      DateTime::Parse(pRawResponse->GetHeaders().at("Last-Modified"),
                      Azure::DateTime::DateFormat::Rfc3339);
  return Response<Models::KeyValue>(std::move(response),
                                    std::move(pRawResponse));
}
Response<Models::KeyValue>
Client::PutKeyValue(Core::Http::_internal::HttpPipeline &pipeline,
                    const Core::Url &url, const PutKeyValueOptions &options,
                    const Core::Context &context) {
  std::string jsonBody;
  {
    auto jsonRoot = Core::Json::_internal::json::object();
    jsonRoot["key"] = options.Entity.Key;
    jsonRoot["label"] = options.Entity.Label;
    jsonRoot["content_type"] = options.Entity.ContentType;
    jsonRoot["value"] = options.Entity.Value;
    jsonRoot["last_modified"] = options.Entity.LastModified;
    for (const auto &p : options.Entity.Tags) {
      jsonRoot["tags"][p.first] = p.second;
    }
    jsonRoot["locked"] = options.Entity.Locked;
    jsonRoot["etag"] = options.Entity.Etag;
    jsonBody = jsonRoot.dump();
  }
  Core::IO::MemoryBodyStream requestBody(
      reinterpret_cast<const uint8_t *>(jsonBody.data()), jsonBody.length());
  auto request =
      Core::Http::Request(Core::Http::HttpMethod::Put, url, &requestBody);
  request.SetHeader("Content-Type", "application/json");
  request.SetHeader("Content-Length", std::to_string(requestBody.Length()));
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.IfMatch.HasValue() && !options.IfMatch.ToString().empty()) {
    request.SetHeader("If-Match", options.IfMatch.ToString());
  }
  if (options.IfNoneMatch.HasValue() &&
      !options.IfNoneMatch.ToString().empty()) {
    request.SetHeader("If-None-Match", options.IfNoneMatch.ToString());
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::KeyValue response;
  {
    const auto &responseBody = pRawResponse->GetBody();
    auto jsonRoot = Core::Json::_internal::json::parse(responseBody.begin(),
                                                       responseBody.end());
    response.Key = jsonRoot["key"].get<std::string>();
    response.Label = jsonRoot["label"].get<std::string>();
    response.ContentType = jsonRoot["content_type"].get<std::string>();
    response.Value = jsonRoot["value"].get<std::string>();
    response.LastModified =
        DateTime::Parse(jsonRoot["last_modified"].get<std::string>(),
                        Azure::DateTime::DateFormat::Rfc3339);
    for (const auto &var0 :
         jsonRoot.count("tags") != 0 && jsonRoot["tags"].is_object()
             ? jsonRoot["tags"]
             : Core::Json::_internal::json::object()) {
      std::string var0Value;
      var0Value = var0.value().get<std::string>();
      response.Tags.emplace(var0.key(), std::move(var0Value));
    }
    response.Locked =
        jsonRoot["locked"].is_boolean()
            ? jsonRoot["locked"].get<bool>()
            : jsonRoot["locked"].get<std::string>() == std::string("true");
    response.Etag = ETag(jsonRoot["etag"].get<std::string>());
  }
  return Response<Models::KeyValue>(std::move(response),
                                    std::move(pRawResponse));
}
Response<Models::KeyValue> Client::DeleteKeyValue(
    Core::Http::_internal::HttpPipeline &pipeline, const Core::Url &url,
    const DeleteKeyValueOptions &options, const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Delete, url);
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.IfMatch.HasValue() && !options.IfMatch.ToString().empty()) {
    request.SetHeader("If-Match", options.IfMatch.ToString());
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (!(httpStatusCode == Core::Http::HttpStatusCode::Ok ||
        httpStatusCode == Core::Http::HttpStatusCode::NoContent)) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::KeyValue response;
  {
    const auto &responseBody = pRawResponse->GetBody();
    auto jsonRoot = Core::Json::_internal::json::parse(responseBody.begin(),
                                                       responseBody.end());
    response.Key = jsonRoot["key"].get<std::string>();
    response.Label = jsonRoot["label"].get<std::string>();
    response.ContentType = jsonRoot["content_type"].get<std::string>();
    response.Value = jsonRoot["value"].get<std::string>();
    response.LastModified =
        DateTime::Parse(jsonRoot["last_modified"].get<std::string>(),
                        Azure::DateTime::DateFormat::Rfc3339);
    for (const auto &var0 :
         jsonRoot.count("tags") != 0 && jsonRoot["tags"].is_object()
             ? jsonRoot["tags"]
             : Core::Json::_internal::json::object()) {
      std::string var0Value;
      var0Value = var0.value().get<std::string>();
      response.Tags.emplace(var0.key(), std::move(var0Value));
    }
    response.Locked =
        jsonRoot["locked"].is_boolean()
            ? jsonRoot["locked"].get<bool>()
            : jsonRoot["locked"].get<std::string>() == std::string("true");
    response.Etag = ETag(jsonRoot["etag"].get<std::string>());
  }
  return Response<Models::KeyValue>(std::move(response),
                                    std::move(pRawResponse));
}
Response<Models::CheckKeyValueResult>
Client::CheckKeyValue(Core::Http::_internal::HttpPipeline &pipeline,
                      const Core::Url &url, const CheckKeyValueOptions &options,
                      const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Head, url);
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  if (options.IfMatch.HasValue() && !options.IfMatch.ToString().empty()) {
    request.SetHeader("If-Match", options.IfMatch.ToString());
  }
  if (options.IfNoneMatch.HasValue() &&
      !options.IfNoneMatch.ToString().empty()) {
    request.SetHeader("If-None-Match", options.IfNoneMatch.ToString());
  }
  if (options.Select.HasValue() &&
      !Head7ItemsItemToString(options.Select.Value()).empty()) {
    request.GetUrl().AppendQueryParameter(
        "$Select", Storage::_internal::UrlEncodeQueryParameter(
                       Head7ItemsItemToString(options.Select.Value())));
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::CheckKeyValueResult response;
  response.SyncToken = pRawResponse->GetHeaders().at("Sync-Token");
  response.ETag = ETag(pRawResponse->GetHeaders().at("ETag"));
  response.LastModified = pRawResponse->GetHeaders().at("Last-Modified");
  return Response<Models::CheckKeyValueResult>(std::move(response),
                                               std::move(pRawResponse));
}
Response<Models::LabelListResult>
Client::GetLabels(Core::Http::_internal::HttpPipeline &pipeline,
                  const Core::Url &url, const GetLabelsOptions &options,
                  const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Get, url);
  if (options.Name.HasValue() && !options.Name.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "name",
        Storage::_internal::UrlEncodeQueryParameter(options.Name.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.After.HasValue() && !options.After.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "After",
        Storage::_internal::UrlEncodeQueryParameter(options.After.Value()));
  }
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  if (options.Select.HasValue() &&
      !Get5ItemsItemToString(options.Select.Value()).empty()) {
    request.GetUrl().AppendQueryParameter(
        "$Select", Storage::_internal::UrlEncodeQueryParameter(
                       Get5ItemsItemToString(options.Select.Value())));
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::LabelListResult response;
  {
    const auto &responseBody = pRawResponse->GetBody();
    auto jsonRoot = Core::Json::_internal::json::parse(responseBody.begin(),
                                                       responseBody.end());
    for (const auto &var0 :
         jsonRoot.count("items") != 0 && jsonRoot["items"].is_array()
             ? jsonRoot["items"]
             : Core::Json::_internal::json::array()) {
      Models::Label vectorElement2;
      vectorElement2.Name = var0["name"].get<std::string>();
      response.Items.emplace_back(std::move(vectorElement2));
    }
    response.NextLink = jsonRoot["@nextLink"].get<std::string>();
  }
  return Response<Models::LabelListResult>(std::move(response),
                                           std::move(pRawResponse));
}
Response<Models::CheckLabelsResult>
Client::CheckLabels(Core::Http::_internal::HttpPipeline &pipeline,
                    const Core::Url &url, const CheckLabelsOptions &options,
                    const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Head, url);
  if (options.Name.HasValue() && !options.Name.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "name",
        Storage::_internal::UrlEncodeQueryParameter(options.Name.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.After.HasValue() && !options.After.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "After",
        Storage::_internal::UrlEncodeQueryParameter(options.After.Value()));
  }
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  if (options.Select.HasValue() &&
      !Head5ItemsItemToString(options.Select.Value()).empty()) {
    request.GetUrl().AppendQueryParameter(
        "$Select", Storage::_internal::UrlEncodeQueryParameter(
                       Head5ItemsItemToString(options.Select.Value())));
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::CheckLabelsResult response;
  response.SyncToken = pRawResponse->GetHeaders().at("Sync-Token");
  return Response<Models::CheckLabelsResult>(std::move(response),
                                             std::move(pRawResponse));
}
Response<Models::KeyValue>
Client::PutLock(Core::Http::_internal::HttpPipeline &pipeline,
                const Core::Url &url, const PutLockOptions &options,
                const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Put, url);
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.IfMatch.HasValue() && !options.IfMatch.ToString().empty()) {
    request.SetHeader("If-Match", options.IfMatch.ToString());
  }
  if (options.IfNoneMatch.HasValue() &&
      !options.IfNoneMatch.ToString().empty()) {
    request.SetHeader("If-None-Match", options.IfNoneMatch.ToString());
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::KeyValue response;
  {
    const auto &responseBody = pRawResponse->GetBody();
    auto jsonRoot = Core::Json::_internal::json::parse(responseBody.begin(),
                                                       responseBody.end());
    response.Key = jsonRoot["key"].get<std::string>();
    response.Label = jsonRoot["label"].get<std::string>();
    response.ContentType = jsonRoot["content_type"].get<std::string>();
    response.Value = jsonRoot["value"].get<std::string>();
    response.LastModified =
        DateTime::Parse(jsonRoot["last_modified"].get<std::string>(),
                        Azure::DateTime::DateFormat::Rfc3339);
    for (const auto &var0 :
         jsonRoot.count("tags") != 0 && jsonRoot["tags"].is_object()
             ? jsonRoot["tags"]
             : Core::Json::_internal::json::object()) {
      std::string var0Value;
      var0Value = var0.value().get<std::string>();
      response.Tags.emplace(var0.key(), std::move(var0Value));
    }
    response.Locked =
        jsonRoot["locked"].is_boolean()
            ? jsonRoot["locked"].get<bool>()
            : jsonRoot["locked"].get<std::string>() == std::string("true");
    response.Etag = ETag(jsonRoot["etag"].get<std::string>());
  }
  return Response<Models::KeyValue>(std::move(response),
                                    std::move(pRawResponse));
}
Response<Models::KeyValue>
Client::DeleteLock(Core::Http::_internal::HttpPipeline &pipeline,
                   const Core::Url &url, const DeleteLockOptions &options,
                   const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Delete, url);
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.IfMatch.HasValue() && !options.IfMatch.ToString().empty()) {
    request.SetHeader("If-Match", options.IfMatch.ToString());
  }
  if (options.IfNoneMatch.HasValue() &&
      !options.IfNoneMatch.ToString().empty()) {
    request.SetHeader("If-None-Match", options.IfNoneMatch.ToString());
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::KeyValue response;
  {
    const auto &responseBody = pRawResponse->GetBody();
    auto jsonRoot = Core::Json::_internal::json::parse(responseBody.begin(),
                                                       responseBody.end());
    response.Key = jsonRoot["key"].get<std::string>();
    response.Label = jsonRoot["label"].get<std::string>();
    response.ContentType = jsonRoot["content_type"].get<std::string>();
    response.Value = jsonRoot["value"].get<std::string>();
    response.LastModified =
        DateTime::Parse(jsonRoot["last_modified"].get<std::string>(),
                        Azure::DateTime::DateFormat::Rfc3339);
    for (const auto &var0 :
         jsonRoot.count("tags") != 0 && jsonRoot["tags"].is_object()
             ? jsonRoot["tags"]
             : Core::Json::_internal::json::object()) {
      std::string var0Value;
      var0Value = var0.value().get<std::string>();
      response.Tags.emplace(var0.key(), std::move(var0Value));
    }
    response.Locked =
        jsonRoot["locked"].is_boolean()
            ? jsonRoot["locked"].get<bool>()
            : jsonRoot["locked"].get<std::string>() == std::string("true");
    response.Etag = ETag(jsonRoot["etag"].get<std::string>());
  }
  return Response<Models::KeyValue>(std::move(response),
                                    std::move(pRawResponse));
}
Response<Models::KeyValueListResult>
Client::GetRevisions(Core::Http::_internal::HttpPipeline &pipeline,
                     const Core::Url &url, const GetRevisionsOptions &options,
                     const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Get, url);
  if (options.Key.HasValue() && !options.Key.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "key",
        Storage::_internal::UrlEncodeQueryParameter(options.Key.Value()));
  }
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.After.HasValue() && !options.After.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "After",
        Storage::_internal::UrlEncodeQueryParameter(options.After.Value()));
  }
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  if (options.Select.HasValue() &&
      !Enum6ToString(options.Select.Value()).empty()) {
    request.GetUrl().AppendQueryParameter(
        "$Select", Storage::_internal::UrlEncodeQueryParameter(
                       Enum6ToString(options.Select.Value())));
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::KeyValueListResult response;
  {
    const auto &responseBody = pRawResponse->GetBody();
    auto jsonRoot = Core::Json::_internal::json::parse(responseBody.begin(),
                                                       responseBody.end());
    for (const auto &var0 :
         jsonRoot.count("items") != 0 && jsonRoot["items"].is_array()
             ? jsonRoot["items"]
             : Core::Json::_internal::json::array()) {
      Models::KeyValue vectorElement2;
      vectorElement2.Key = var0["key"].get<std::string>();
      vectorElement2.Label = var0["label"].get<std::string>();
      vectorElement2.ContentType = var0["content_type"].get<std::string>();
      vectorElement2.Value = var0["value"].get<std::string>();
      vectorElement2.LastModified =
          DateTime::Parse(var0["last_modified"].get<std::string>(),
                          Azure::DateTime::DateFormat::Rfc3339);
      for (const auto &var2 :
           var0.count("tags") != 0 && var0["tags"].is_object()
               ? var0["tags"]
               : Core::Json::_internal::json::object()) {
        std::string var2Value;
        var2Value = var2.value().get<std::string>();
        vectorElement2.Tags.emplace(var2.key(), std::move(var2Value));
      }
      vectorElement2.Locked =
          var0["locked"].is_boolean()
              ? var0["locked"].get<bool>()
              : var0["locked"].get<std::string>() == std::string("true");
      vectorElement2.Etag = ETag(var0["etag"].get<std::string>());
      response.Items.emplace_back(std::move(vectorElement2));
    }
    response.NextLink = jsonRoot["@nextLink"].get<std::string>();
  }
  return Response<Models::KeyValueListResult>(std::move(response),
                                              std::move(pRawResponse));
}
Response<Models::CheckRevisionsResult> Client::CheckRevisions(
    Core::Http::_internal::HttpPipeline &pipeline, const Core::Url &url,
    const CheckRevisionsOptions &options, const Core::Context &context) {
  auto request = Core::Http::Request(Core::Http::HttpMethod::Head, url);
  if (options.Key.HasValue() && !options.Key.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "key",
        Storage::_internal::UrlEncodeQueryParameter(options.Key.Value()));
  }
  if (options.Label.HasValue() && !options.Label.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "label",
        Storage::_internal::UrlEncodeQueryParameter(options.Label.Value()));
  }
  if (options.SyncToken.HasValue() && !options.SyncToken.Value().empty()) {
    request.SetHeader("Sync-Token", options.SyncToken.Value());
  }
  request.GetUrl().AppendQueryParameter("api-version", "1.0");
  if (options.After.HasValue() && !options.After.Value().empty()) {
    request.GetUrl().AppendQueryParameter(
        "After",
        Storage::_internal::UrlEncodeQueryParameter(options.After.Value()));
  }
  if (options.AcceptDatetime.HasValue() &&
      !options.AcceptDatetime.Value().empty()) {
    request.SetHeader("Accept-Datetime", options.AcceptDatetime.Value());
  }
  if (options.Select.HasValue() &&
      !Enum7ToString(options.Select.Value()).empty()) {
    request.GetUrl().AppendQueryParameter(
        "$Select", Storage::_internal::UrlEncodeQueryParameter(
                       Enum7ToString(options.Select.Value())));
  }
  auto pRawResponse = pipeline.Send(request, context);
  auto httpStatusCode = pRawResponse->GetStatusCode();
  if (httpStatusCode != Core::Http::HttpStatusCode::Ok) {
    throw Storage::StorageException::CreateFromResponse(
        std::move(pRawResponse));
  }
  Models::CheckRevisionsResult response;
  response.SyncToken = pRawResponse->GetHeaders().at("Sync-Token");
  return Response<Models::CheckRevisionsResult>(std::move(response),
                                                std::move(pRawResponse));
}
} // namespace _detail
} // namespace AppConfiguration
} // namespace Data
} // namespace Azure